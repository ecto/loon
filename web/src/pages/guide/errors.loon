; errors.loon — Error handling guide

[fn guide-errors-page []
  [doc-page "Error Handling" "Option, Result, and the ? operator."

    [doc-section "Option Type"
      [doc-text "Option represents a value that may or may not exist. There is no " [doc-code "nil"] " or " [doc-code "null"] " in Loon."]
      [code-block {:label "LOON"} [str "[let found [get {:a 1} :b]]\n" "; found is None\n" "\n" "[let found [get {:a 1} :a]]\n" "; found is [Some 1]"]]
      [doc-text "Use " [doc-code "Some"] " to wrap a value and " [doc-code "None"] " for absence."]]

    [doc-section "Result Type"
      [doc-text "Result represents an operation that can succeed or fail."]
      [code-block {:label "LOON"} [str "[fn parse-int [s]\n" "  [match [try-parse s]\n" "    [Some n] => [Ok n]\n" "    None => [Err \"not a number\"]]]"]]
      [doc-text [doc-code "Ok"] " wraps a success value. " [doc-code "Err"] " wraps an error."]]

    [doc-section "Pattern Matching on Results"
      [doc-text "Use " [doc-code "match"] " to handle both cases explicitly."]
      [code-block {:label "LOON"} [str "[match [parse-int \"42\"]\n" "  [Ok n] => [println [str \"got: \" n]]\n" "  [Err e] => [println [str \"error: \" e]]]"]]
      [doc-text "The compiler ensures you handle both variants — no unhandled errors."]]

    [doc-section "The ? Operator"
      [doc-text "The " [doc-code "?"] " operator unwraps Ok and propagates Err to the caller."]
      [code-block {:label "LOON"} [str "[fn load-config [path]\n" "  [let text [IO.read-file path]?]\n" "  [let data [parse-json text]?]\n" "  [Ok data]]"]]
      [doc-text "If any " [doc-code "?"] " hits an Err, the function returns that Err immediately."]
      [doc-note "info" "The ? operator works on both Result and Option. On None it returns None early."]]

    [doc-section "Try Blocks"
      [doc-text "Use " [doc-code "try"] " to catch errors within a block and get a Result back."]
      [code-block {:label "LOON"} [str "[let result [try\n" "  [let a [parse-int \"10\"]?]\n" "  [let b [parse-int \"bad\"]?]\n" "  [+ a b]]]\n" "; result is [Err \"not a number\"]"]]
      [doc-text "Everything inside " [doc-code "try"] " can use " [doc-code "?"] " freely. The block produces a Result."]]

    [doc-section "Handle for Effects"
      [doc-text "For errors that cross effect boundaries, use " [doc-code "handle"] " with the " [doc-code "Fail"] " effect."]
      [code-block {:label "LOON"} [str "[handle [divide 10 0]\n" "  [Fail.raise msg] => [println [str \"caught: \" msg]]]"]]
      [doc-text "This bridges the gap between Result values and effectful error handling."]
      [doc-note "tip" "Prefer Result and ? for local error handling. Use Fail for errors that need to cross handler boundaries."]]

    [doc-section "Error Codes"
      [doc-text "Compiler errors include an alphanumeric code. Use " [doc-code "loon explain"] " to get a detailed explanation."]
      [code-block {:label "SHELL"} [str "$ loon explain E0042\n" "E0042: Use after move\n" "\n" "A value was used after its ownership\n" "was transferred to another binding.\n" "..."]]
      [doc-text "Each explanation includes the rule, a minimal example, and a suggested fix."]]

    [doc-prev-next "Testing" "/guide/testing" "Syntax" "/ref/syntax"]]]
