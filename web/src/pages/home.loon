; home.loon — Landing page: splash hero + short tour

; --- Loon bird image ---
[fn loon-img []
  [img-el {:src "/loon.png" :alt "Loon bird" :class "hero-loon"}]]

; --- Background code snippet with label ---
[fn bg-snippet [label code idx]
  [div {:class [str "hero-bg-snippet hero-bg-snippet--" [str idx]]}
    [span {:class "hero-bg-label"} label]
    code]]

; --- Background code snippets ---
[fn bg-snippets []
  [div {:class "hero-bg"}
    [bg-snippet "composition" "[fn compose [f g]\n  [fn [x] [f [g x]]]]" 1]
    [bg-snippet "pipes" "[pipe data\n  [filter valid?]\n  [map transform]\n  [sort-by :score]]" 2]
    [bg-snippet "effects" "[effect Logger\n  [log [msg : Str] : Unit]]" 3]
    [bg-snippet "types" "[type Option\n  [Some a]\n  None]" 4]
    [bg-snippet "pattern matching" "[match shape\n  [Circle r] [* 3.14 r r]\n  [Rect w h] [* w h]]" 5]
    [bg-snippet "handlers" "[handle [greet]\n  [Ask.prompt q] \"World\"]" 6]
    [bg-snippet "ownership" "[let items #[1 2 3]]\n[let sorted [sort items]]\n; items moved to sorted" 7]
    [bg-snippet "macros" "[macro when [test & body]\n  `[if ~test [do ~@body] []]]" 8]]]

; --- Tour section helper ---
[fn tour-section [title desc link-text link-href source]
  [div {:class "tour-section"}
    [div {:class "tour-section-head"}
      [p {:class "tour-section-title"} title]
      [p {:class "tour-section-desc"} desc]
      [a-el {:class "tour-section-link" :href link-href} [str link-text " →"]]]
    [div {:class "tour-section-code"}
      [code-block {} source]]]]

; --- Page ---
[fn home-page []
  [div {:class "page" :style {:padding "0"}}

    ; === Hero ===
    [section-el {:class "hero"}
      [bg-snippets]
      [loon-img]
      [div {:class "hero-content"}
        [div {:class "hero-text"}
          [div {:class "hero-wordmark"} "loon"]
          [p {:class "hero-tagline"}
            "A functional language with invisible types, safe ownership, and algebraic effects."]
          [p {:class "hero-sub"}
            "Hindley-Milner inference eliminates type annotations. Ownership checking runs without lifetime syntax. Effects replace exceptions, async, and state."]
          [div {:class "hero-actions"}
            [btn {:href "/install"} "Install"]
            [btn-secondary {:href "/tour"} "Take the tour"]]
          [div {:class "hero-install"}
            [code-block {:class "copyable"} "curl -fsSL https://loonlang.com/install.sh | sh"]]]]]

    ; === Tour ===
    [div {:class "tour"}
      [tour-section
        "Everything is an expression"
        "No statements, no void returns. Every construct — if, match, let — produces a value. Square brackets replace parentheses for a clean, uniform syntax."
        "Guide: Basics"
        "/guide/basics"
        [str
          "[let greeting\n"
          "  [if [> hour 17]\n"
          "    \"Good evening\"\n"
          "    \"Hello\"]]\n"
          "\n"
          "[println greeting]  ; \"Good evening\""]]

      [tour-section
        "Functions and pipes"
        "First-class functions with implicit do blocks. Pipe chains thread data through transformations without nesting or temp variables."
        "Guide: Functions"
        "/guide/functions"
        [str
          "[fn process [items]\n"
          "  [pipe items\n"
          "    [filter [fn [x] [> [get x :score 0] 0.5]]]\n"
          "    [map [fn [x] [update x :score [fn [s] [* s 2]]]]]\n"
          "    [sort-by [fn [x] [get x :score 0]]]]]"]]

      [tour-section
        "Types without typing"
        "Complete Hindley-Milner inference with let-polymorphism and row types for records. The compiler infers every type — you never write one."
        "Concepts: Invisible types"
        "/concepts/invisible-types"
        [str
          "; The compiler infers:\n"
          ";   compose : (b -> c) -> (a -> b) -> (a -> c)\n"
          "[fn compose [f g]\n"
          "  [fn [x] [f [g x]]]]\n"
          "\n"
          "[let inc-dbl [compose [fn [n] [+ n 1]]\n"
          "                      [fn [n] [* n 2]]]]\n"
          "[inc-dbl 5]  ; 11"]]

      [tour-section
        "Ownership without lifetimes"
        "Values move by default. The compiler tracks ownership through dataflow analysis and catches use-after-move, double-free, and aliasing errors — no annotations needed."
        "Concepts: Ownership"
        "/concepts/ownership"
        [str
          "[let items #[1 2 3]]\n"
          "[let sorted [sort items]]\n"
          "\n"
          "; items has moved — using it here\n"
          "; is a compile error:\n"
          "; [println items]  ; error: moved\n"
          "\n"
          "[println sorted]  ; #[1 2 3]"]]

      [tour-section
        "Algebraic effects"
        "Declare effects as interfaces, perform them in functions, handle them at call sites. Effects replace exceptions, async/await, and mutable state with a single composable mechanism."
        "Concepts: Effects"
        "/concepts/effects"
        [str
          "[effect Ask\n"
          "  [prompt [q : Str] : Str]]\n"
          "\n"
          "[fn greet []\n"
          "  [let name [Ask.prompt \"Name?\"]]\n"
          "  [str \"Hello, \" name \"!\"]]\n"
          "\n"
          "; The caller decides how to handle it\n"
          "[handle [greet]\n"
          "  [Ask.prompt q] \"World\"]  ; \"Hello, World!\""]]

      [tour-section
        "Pattern matching"
        "Match on literals, ADT constructors, and wildcards. Destructure values directly in let bindings, function parameters, and match arms."
        "Guide: Pattern matching"
        "/guide/pattern-matching"
        [str
          "[type Shape\n"
          "  [Circle Float]\n"
          "  [Rect Float Float]]\n"
          "\n"
          "[fn area [s]\n"
          "  [match s\n"
          "    [Circle r]  [* 3.14 r r]\n"
          "    [Rect w h]  [* w h]]]\n"
          "\n"
          "[area [Circle 5.0]]  ; 78.5"]]]

    ]]
